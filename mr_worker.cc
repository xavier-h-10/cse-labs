#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <algorithm>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include <functional>

#include "rpc.h"
#include "mr_protocol.h"

const string prefix = "mr-";

using namespace std;

struct KeyVal {
    string key;
    string val;
};

int hashStr(const string &str) {
    hash <string> h;
    size_t res = h(str);
    return res % REDUCER_COUNT;
}

bool isLetter(char p) {
    return ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z'));
}


//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector <KeyVal> Map(const string &filename, const string &content) {
    // Copy your code from mr_sequential.cc here.
    int len = content.length();
    string str = "";
    KeyVal tmp;
    tmp.val = "1";
    vector <KeyVal> ans;
    ans.clear();
    for (int i = 0; i < len; i++) {
        if (isLetter(content[i])) {
            str += content[i];
        } else {
            if (str.length() > 0) {
                tmp.key = str;
                ans.push_back(tmp);
            }
            str = "";
        }
    }
    return ans;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector <string> &values) {
    // Copy your code from mr_sequential.cc here.
    int len = values.size();
    int res = 0;
    for (int i = 0; i < len; i++) {
        string tmp = values[i];
        int tmp1 = atoi(tmp.c_str());
        res += tmp1;
    }
    return to_string(res);
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);

typedef string (*REDUCEF)(const string &key, const vector <string> &values);

class Worker {
public:
    Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

    void doWork();

private:
    void doMap(int index, const string &filename);

    void doReduce(int index, int tot);

    void doSubmit(mr_tasktype taskType, int index);


    mutex mtx;
    int id;

    rpcc *cl;
    std::string basedir;
    MAPF mapf;
    REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf) {
    this->basedir = dir;
    this->mapf = mf;
    this->reducef = rf;

//    cout<<"worker called id="<<id<<endl;

    sockaddr_in dstsock;
    make_sockaddr(dst.c_str(), &dstsock);
    this->cl = new rpcc(dstsock);
    if (this->cl->bind() < 0) {
        printf("mr worker: call bind error\n");
    }
}

//void Worker::doMap(int index, const vector<string> &filenames)
//此处接口改为只对一个文件map
void Worker::doMap(int index, const string &filename) {
    // Lab2: Your code goes here.
    string content;
    getline(ifstream(filename), content, '\0');
    vector <KeyVal> res = Map(filename, content);
    string contents[REDUCER_COUNT];
    int size = res.size();
//    printf("worker::domap id=%d index=%d filename=%s\n",id,index,filename.c_str());
//    printf("worker::domap id=%d index=%d checkpoint1 size=%d\n",id,index,size);

    for (int i = 0; i < REDUCER_COUNT; i++) {
        contents[i] = "";
    }
    for (int i = 0; i < size; i++) {
        int pos = hashStr(res[i].key);
//        out[pos] << res[i].key << endl;
//        out[pos] << res[i].val << endl;
        contents[pos] += res[i].key + '\n' + res[i].val + '\n';
//        if (i % 100 == 0) {
//            printf("worker::domap id=%d index=%d checkpoint1 i=%d\n", id, index, i);
//        }
    }
//    printf("worker::domap id=%d index=%d checkpoint2\n", id, index);
    for (int i = 0; i < REDUCER_COUNT; i++) {
        string des = prefix + to_string(index) + "-" + to_string(i);
        //一定要一起写入文件,否则超时
        ofstream out(des, ios::out);
        out << contents[i];
        out.close();
    }
//    printf("worker::domap id=%d index=%d complete!\n", id, index);

}

void Worker::doReduce(int index, int tot) {
    // Lab2: Your code goes here.
    vector <KeyVal> intermediate;
    vector <string> s;
    intermediate.clear();
//    printf("worker::doreduce called index=%d tot=%d\n", index, tot);
    for (int i = 0; i < tot; i++) {
        s.clear();
        string filename = prefix + to_string(i) + "-" + to_string(index);
        ifstream in(filename);
        string str;
        while (in >> str) {
            s.push_back(str);
        }
        in.close();
        int size = s.size();
        KeyVal tmp;
        for (int i = 0; i + 1 < size; i += 2) {
            tmp.key = s[i];
            tmp.val = s[i + 1];
            intermediate.push_back(tmp);
        }
    }
    sort(intermediate.begin(), intermediate.end(),
         [](KeyVal const &a, KeyVal const &b) {
             return a.key < b.key;
         });

//    cout << "doReduce called" << "mr-out-" + to_string(index) << endl;

    ofstream out("mr-out-" + to_string(index), ios::out);
    string res = "";

    for (unsigned int i = 0; i < intermediate.size();) {
        unsigned int j = i + 1;
        for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;)
            j++;

        vector <string> values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(intermediate[k].val);
        }

        string output = Reduce(intermediate[i].key, values);
//        out << intermediate[i].key.data() << " " << output.data() << endl;
        res += intermediate[i].key + ' ' + output + '\n';
        i = j;
    }
    out << res;
    out.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index) {
    bool b;
//    printf("worker::dosubmit id=%d index=%d\n", id, index);
    mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
    if (ret != mr_protocol::OK) {
        fprintf(stderr, "submit task failed\n");
        exit(-1);
    }
}

void Worker::doWork() {
    for (;;) {

        //
        // Lab2: Your code goes here.
        // Hints: send asktask RPC call to coordinator
        // if mr_tasktype::MAP, then doMap and doSubmit
        // if mr_tasktype::REDUCE, then doReduce and doSubmit
        // if mr_tasktype::NONE, meaning currently no work is needed, then sleep
        //
        mr_protocol::AskTaskResponse res;
        int ret = this->cl->call(mr_protocol::asktask, id, res);
        if (ret == mr_protocol::OK) {
            if (res.taskType == mr_tasktype::MAP) {
                doMap(res.index, res.filename);
                doSubmit(mr_tasktype::MAP, res.index);
            } else if (res.taskType == mr_tasktype::REDUCE) {
                doReduce(res.index, res.tot);
                doSubmit(mr_tasktype::REDUCE, res.index);
            } else {
                sleep(100);
            }
        } else {
            sleep(100);
        }
    }
}

int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
        exit(1);
    }

    MAPF mf = Map;
    REDUCEF rf = Reduce;

    Worker w(argv[1], argv[2], mf, rf);

    w.doWork();

    return 0;
}

